<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>British File Processor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        textarea, input[type="file"], button {
            display: block;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>British File Processor</h1>

    <h2>Encode Text into .british</h2>
    <textarea id="textInput" rows="8" cols="50" placeholder="Enter text here..."></textarea>
    <button id="encodeTextButton">Encode to .british</button>

    <h2>Encode Media into .britishm</h2>
    <input type="file" id="mediaInput" accept="image/*,video/*,audio/*">
    <button id="encodeMediaButton">Encode to .britishm</button>

    <h2>Decode British Files</h2>
    <input type="file" id="fileInput" accept=".british,.britishm">
    <button id="decodeButton">Decode File</button>
    <pre id="output" style="white-space: pre-wrap; background: #f4f4f4; padding: 10px;"></pre>
    <div id="mediaOutput"></div>

    <script>
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();

        const randomNumbers = Math.floor(1000 + Math.random() * 9000); // Random 4-digit number
        const baseKey = `BritishLove${randomNumbers}`;
        let cryptoKey;

        // Derive encryption key
        async function deriveKey(password) {
            const hash = await crypto.subtle.digest("SHA-256", encoder.encode(password));
            return hash; // 32-byte key
        }

        // Set the key
        deriveKey(baseKey).then((key) => {
            cryptoKey = key;
            console.log("Encryption Key Set:", baseKey);
        });

        // Encrypt
        async function encrypt(data) {
            const key = await crypto.subtle.importKey("raw", cryptoKey, { name: "AES-CBC" }, false, ["encrypt"]);
            const iv = crypto.getRandomValues(new Uint8Array(16));
            const encrypted = await crypto.subtle.encrypt({ name: "AES-CBC", iv }, key, data);
            return { encryptedData: new Uint8Array(encrypted), iv };
        }

        // Decrypt
        async function decrypt(data, iv) {
            const key = await crypto.subtle.importKey("raw", cryptoKey, { name: "AES-CBC" }, false, ["decrypt"]);
            const decrypted = await crypto.subtle.decrypt({ name: "AES-CBC", iv }, key, data);
            return new Uint8Array(decrypted);
        }

        // Encode text
        document.getElementById("encodeTextButton").addEventListener("click", async () => {
            const text = document.getElementById("textInput").value;
            if (!text) {
                alert("Please enter text.");
                return;
            }

            const content = encoder.encode(text);
            const signature = encoder.encode("BRSH"); // Signature for text
            const { encryptedData, iv } = await encrypt(new Uint8Array([...signature, ...content]));
            const header = new Uint8Array([encryptedData.length & 0xFF, (encryptedData.length >> 8) & 0xFF, ...iv]);

            const fileData = new Blob([header, encryptedData]);
            const link = document.createElement("a");
            link.href = URL.createObjectURL(fileData);
            link.download = "output.british";
            link.click();
        });

        // Encode media
        document.getElementById("encodeMediaButton").addEventListener("click", async () => {
            const fileInput = document.getElementById("mediaInput").files[0];
            if (!fileInput) {
                alert("Please upload a media file.");
                return;
            }

            const arrayBuffer = await fileInput.arrayBuffer();
            const signature = encoder.encode("BRSHM"); // Signature for media
            const content = new Uint8Array(arrayBuffer);
            const { encryptedData, iv } = await encrypt(new Uint8Array([...signature, ...content]));
            const header = new Uint8Array([encryptedData.length & 0xFF, (encryptedData.length >> 8) & 0xFF, ...iv]);

            const fileData = new Blob([header, encryptedData]);
            const link = document.createElement("a");
            link.href = URL.createObjectURL(fileData);
            link.download = "output.britishm";
            link.click();
        });

        // Decode file
      document.getElementById("decodeButton").addEventListener("click", async () => {
    const fileInput = document.getElementById("fileInput").files[0];
    if (!fileInput) {
        alert("Please upload a .british or .britishm file.");
        return;
    }

    const buffer = await fileInput.arrayBuffer();
    const data = new Uint8Array(buffer);

    const length = data[0] + (data[1] << 8);
    const iv = data.slice(2, 18);
    const encryptedData = data.slice(18, 18 + length);

    try {
        const decryptedData = await decrypt(encryptedData, iv);
        const signature = decoder.decode(decryptedData.slice(0, 5));

        if (signature === "BRSH") {
            // Decode text file
            const content = decoder.decode(decryptedData.slice(5));
            document.getElementById("output").textContent = content;
            document.getElementById("mediaOutput").innerHTML = "";
        } else if (signature === "BRSHM") {
            // Decode media file
            const mediaContent = decryptedData.slice(5);
            const blob = new Blob([mediaContent]);

            // Infer MIME type from file signature
            const mimeType = inferMimeType(mediaContent);

            if (mimeType.startsWith("image/")) {
                const img = document.createElement("img");
                img.src = URL.createObjectURL(blob);
                img.alt = "Decrypted Image";
                img.style.maxWidth = "100%";
                document.getElementById("mediaOutput").innerHTML = "";
                document.getElementById("mediaOutput").appendChild(img);
            } else if (mimeType.startsWith("video/")) {
                const video = document.createElement("video");
                video.src = URL.createObjectURL(blob);
                video.controls = true;
                video.style.maxWidth = "100%";
                document.getElementById("mediaOutput").innerHTML = "";
                document.getElementById("mediaOutput").appendChild(video);
            } else if (mimeType.startsWith("audio/")) {
                const audio = document.createElement("audio");
                audio.src = URL.createObjectURL(blob);
                audio.controls = true;
                document.getElementById("mediaOutput").innerHTML = "";
                document.getElementById("mediaOutput").appendChild(audio);
            } else {
                alert("Unsupported media type. Cannot display content.");
            }
            document.getElementById("output").textContent = "";
        } else {
            alert("Invalid file signature.");
        }
    } catch (error) {
        console.error(error);
        alert("Failed to decode the file.");
    }
});

// Helper function to infer MIME type from file signature
function inferMimeType(content) {
    const signatures = {
        "image/jpeg": [0xFF, 0xD8, 0xFF],
        "image/png": [0x89, 0x50, 0x4E, 0x47],
        "image/gif": [0x47, 0x49, 0x46],
        "video/mp4": [0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70],
        "audio/mpeg": [0xFF, 0xFB],
        "audio/wav": [0x52, 0x49, 0x46, 0x46],
    };

    for (const [mimeType, signature] of Object.entries(signatures)) {
        if (content.slice(0, signature.length).every((byte, i) => byte === signature[i])) {
            return mimeType;
        }
    }
    return "application/octet-stream"; // Default unknown type
}

    </script>
</body>
</html>
